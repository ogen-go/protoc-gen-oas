// Code generated by protoc-gen-oas, DO NOT EDIT.
package proxypb

import (
	oas "github.com/ogen-go/protoc-gen-oas/integration/proxypb/oas"
)

func indirectOf[P ~*T, T any](p P) (zero T) {
	return zero
}

func elemOf[S ~[]T, T any](s S) (zero T) {
	return zero
}

func valueOf[M ~map[K]V, K comparable, V any](m M) (zero V) {
	return zero
}

func initPtr[P ~*T, T any](p *P) {
	var zero T
	*p = &zero
}

func insertMap[M ~map[K]V, K comparable, V any](m *M, k K, v V) {
	if *m == nil {
		*m = make(M)
	}
	(*m)[k] = v
}

func (pm *ChildModel1) FromOpenAPI(om oas.ChildModel1) {
	if ogenVal, ok := om.ChildB1.Get(); ok {
		pm.ChildB1 = &ogenVal
	}

	if ogenVal, ok := om.ChildStr1.Get(); ok {
		pm.ChildStr1 = &ogenVal
	}
}

func (pm *ChildModel1) ToOpenAPI() (om oas.ChildModel1) {
	if pm.ChildB1 != nil {
		ogenVal := om.ChildB1.Value
		{
			ogenVal = *pm.ChildB1
		}
		om.ChildB1.SetTo(ogenVal)
	}

	if pm.ChildStr1 != nil {
		ogenVal := om.ChildStr1.Value
		{
			ogenVal = *pm.ChildStr1
		}
		om.ChildStr1.SetTo(ogenVal)
	}
	return om
}

func (pm *StringMessage) FromOpenAPI(om oas.StringMessage) {
	if ogenVal, ok := om.Value.Get(); ok {
		pm.Value = ogenVal
	}
}

func (pm *StringMessage) ToOpenAPI() (om oas.StringMessage) {
	{
		ogenVal := om.Value.Value
		{
			ogenVal = pm.Value
		}
		om.Value.SetTo(ogenVal)
	}
	return om
}

func (pm *TestModel) FromOpenAPI(om oas.TestModel) {
	if ogenVal, ok := om.Value.Get(); ok {
		pm.Value = &ogenVal
	}

	for _, ogenVal := range om.ValueArray {
		protoVal := elemOf(pm.ValueArray)
		protoVal = ogenVal

		pm.ValueArray = append(pm.ValueArray, protoVal)
	}

	for _, ogenVal := range om.ValueDeprec {
		protoVal := elemOf(pm.ValueDeprec)
		protoVal = ogenVal

		pm.ValueDeprec = append(pm.ValueDeprec, protoVal)
	}

	if ogenVal, ok := om.Str1.Get(); ok {
		pm.Str1 = &ogenVal
	}

	if ogenVal, ok := om.B1.Get(); ok {
		pm.B1 = &ogenVal
	}

	if ogenVal, ok := om.B2.Get(); ok {
		pm.B2 = &ogenVal
	}

	if ogenVal, ok := om.Str2.Get(); ok {
		pm.Str2 = &ogenVal
	}

	if ogenVal, ok := om.Str3.Get(); ok {
		pm.Str3 = &ogenVal
	}

	if ogenVal, ok := om.OptionalFloat.Get(); ok {
		pm.OptionalFloat = &ogenVal
	}

	if ogenVal, ok := om.OptionalDouble.Get(); ok {
		pm.OptionalDouble = &ogenVal
	}

	if ogenVal, ok := om.OptionalInt64.Get(); ok {
		pm.OptionalInt64 = &ogenVal
	}

	if ogenVal, ok := om.OptionalUint32.Get(); ok {
		pm.OptionalUint32 = &ogenVal
	}

	if ogenVal, ok := om.OptionalUint64.Get(); ok {
		pm.OptionalUint64 = &ogenVal
	}

	if ogenVal, ok := om.OptionalSint32.Get(); ok {
		pm.OptionalSint32 = &ogenVal
	}

	if ogenVal, ok := om.OptionalSint64.Get(); ok {
		pm.OptionalSint64 = &ogenVal
	}

	if ogenVal, ok := om.OptionalFixed32.Get(); ok {
		pm.OptionalFixed32 = &ogenVal
	}

	if ogenVal, ok := om.OptionalFixed64.Get(); ok {
		pm.OptionalFixed64 = &ogenVal
	}

	if ogenVal, ok := om.OptionalSfixed32.Get(); ok {
		pm.OptionalSfixed32 = &ogenVal
	}

	if ogenVal, ok := om.OptionalSfixed64.Get(); ok {
		pm.OptionalSfixed64 = &ogenVal
	}

	for _, ogenVal := range om.RepeatedInt64 {
		protoVal := elemOf(pm.RepeatedInt64)
		protoVal = ogenVal

		pm.RepeatedInt64 = append(pm.RepeatedInt64, protoVal)
	}

	for _, ogenVal := range om.RepeatedUint64 {
		protoVal := elemOf(pm.RepeatedUint64)
		protoVal = ogenVal

		pm.RepeatedUint64 = append(pm.RepeatedUint64, protoVal)
	}

	for _, ogenVal := range om.RepeatedFixed64 {
		protoVal := elemOf(pm.RepeatedFixed64)
		protoVal = ogenVal

		pm.RepeatedFixed64 = append(pm.RepeatedFixed64, protoVal)
	}

	for _, ogenVal := range om.RepeatedSfixed64 {
		protoVal := elemOf(pm.RepeatedSfixed64)
		protoVal = ogenVal

		pm.RepeatedSfixed64 = append(pm.RepeatedSfixed64, protoVal)
	}

	for _, ogenVal := range om.RepeatedBool {
		protoVal := elemOf(pm.RepeatedBool)
		protoVal = ogenVal

		pm.RepeatedBool = append(pm.RepeatedBool, protoVal)
	}

	for _, ogenVal := range om.RepeatedString {
		protoVal := elemOf(pm.RepeatedString)
		protoVal = ogenVal

		pm.RepeatedString = append(pm.RepeatedString, protoVal)
	}

	if ogenVal, ok := om.NestedChild1.Get(); ok {
		pm.NestedChild_1 = new(TestModel_NestedChild)
		pm.NestedChild_1.FromOpenAPI(ogenVal)
	}

	if ogenVal, ok := om.ChildModel1.Get(); ok {
		pm.ChildModel_1 = new(ChildModel1)
		pm.ChildModel_1.FromOpenAPI(ogenVal)
	}

	for _, ogenVal := range om.ChildModel2 {
		protoVal := elemOf(pm.ChildModel_2)
		protoVal = new(ChildModel1)
		protoVal.FromOpenAPI(ogenVal)

		pm.ChildModel_2 = append(pm.ChildModel_2, protoVal)
	}

	if ogenVal, ok := om.Bar.Get(); ok {
		pm.Bar = new(ChildModel1)
		pm.Bar.FromOpenAPI(ogenVal)
	}

	if om.RecursiveChild != nil {
		ogenVal := *om.RecursiveChild
		pm.RecursiveChild = new(TestModel)
		pm.RecursiveChild.FromOpenAPI(ogenVal)
	}

	if ogenVal, ok := om.ChildStrMap.Get(); ok {
		for key, ogenVal := range ogenVal {
			protoVal := valueOf(pm.ChildStrMap)
			protoVal = new(ChildModel1)
			protoVal.FromOpenAPI(ogenVal)

			insertMap(&pm.ChildStrMap, key, protoVal)
		}
	}

	if ogenVal, ok := om.StrToIntMap.Get(); ok {
		for key, ogenVal := range ogenVal {
			protoVal := valueOf(pm.StrToIntMap)
			protoVal = ogenVal

			insertMap(&pm.StrToIntMap, key, protoVal)
		}
	}

	if ogenVal, ok := om.StrToStrMap.Get(); ok {
		for key, ogenVal := range ogenVal {
			protoVal := valueOf(pm.StrToStrMap)
			protoVal = ogenVal

			insertMap(&pm.StrToStrMap, key, protoVal)
		}
	}

	if ogenVal, ok := om.Category.Get(); ok {
		pm.Category = new(TestModel_Category)
		pm.Category.FromOpenAPI(ogenVal)
	}

	if ogenVal, ok := om.Template.Get(); ok {
		pm.Template = &ogenVal
	}

	if ogenVal, ok := om.Msg.Get(); ok {
		pm.Msg = &ogenVal
	}

	if ogenVal, ok := om.Arena.Get(); ok {
		pm.Arena = &ogenVal
	}

	if ogenVal, ok := om.ImportedEnum.Get(); ok {
		pm.ImportedEnum = new(TestEnum)
		pm.ImportedEnum.FromOpenAPI(ogenVal)
	}

	if ogenVal, ok := om.Phase.Get(); ok {
		pm.Phase = &ogenVal
	}

	if ogenVal, ok := om.ClearPhase.Get(); ok {
		pm.ClearPhase = &ogenVal
	}
}

func (pm *TestModel) ToOpenAPI() (om oas.TestModel) {
	if pm.Value != nil {
		ogenVal := om.Value.Value
		{
			ogenVal = *pm.Value
		}
		om.Value.SetTo(ogenVal)
	}

	{
		for _, protoVal := range pm.ValueArray {
			ogenElem := elemOf(om.ValueArray)
			{
				ogenElem = protoVal
			}

			om.ValueArray = append(om.ValueArray, ogenElem)
		}
	}

	{
		for _, protoVal := range pm.ValueDeprec {
			ogenElem := elemOf(om.ValueDeprec)
			{
				ogenElem = protoVal
			}

			om.ValueDeprec = append(om.ValueDeprec, ogenElem)
		}
	}

	if pm.Str1 != nil {
		ogenVal := om.Str1.Value
		{
			ogenVal = *pm.Str1
		}
		om.Str1.SetTo(ogenVal)
	}

	if pm.B1 != nil {
		ogenVal := om.B1.Value
		{
			ogenVal = *pm.B1
		}
		om.B1.SetTo(ogenVal)
	}

	if pm.B2 != nil {
		ogenVal := om.B2.Value
		{
			ogenVal = *pm.B2
		}
		om.B2.SetTo(ogenVal)
	}

	if pm.Str2 != nil {
		ogenVal := om.Str2.Value
		{
			ogenVal = *pm.Str2
		}
		om.Str2.SetTo(ogenVal)
	}

	if pm.Str3 != nil {
		ogenVal := om.Str3.Value
		{
			ogenVal = *pm.Str3
		}
		om.Str3.SetTo(ogenVal)
	}

	if pm.OptionalFloat != nil {
		ogenVal := om.OptionalFloat.Value
		{
			ogenVal = *pm.OptionalFloat
		}
		om.OptionalFloat.SetTo(ogenVal)
	}

	if pm.OptionalDouble != nil {
		ogenVal := om.OptionalDouble.Value
		{
			ogenVal = *pm.OptionalDouble
		}
		om.OptionalDouble.SetTo(ogenVal)
	}

	if pm.OptionalInt64 != nil {
		ogenVal := om.OptionalInt64.Value
		{
			ogenVal = *pm.OptionalInt64
		}
		om.OptionalInt64.SetTo(ogenVal)
	}

	if pm.OptionalUint32 != nil {
		ogenVal := om.OptionalUint32.Value
		{
			ogenVal = *pm.OptionalUint32
		}
		om.OptionalUint32.SetTo(ogenVal)
	}

	if pm.OptionalUint64 != nil {
		ogenVal := om.OptionalUint64.Value
		{
			ogenVal = *pm.OptionalUint64
		}
		om.OptionalUint64.SetTo(ogenVal)
	}

	if pm.OptionalSint32 != nil {
		ogenVal := om.OptionalSint32.Value
		{
			ogenVal = *pm.OptionalSint32
		}
		om.OptionalSint32.SetTo(ogenVal)
	}

	if pm.OptionalSint64 != nil {
		ogenVal := om.OptionalSint64.Value
		{
			ogenVal = *pm.OptionalSint64
		}
		om.OptionalSint64.SetTo(ogenVal)
	}

	if pm.OptionalFixed32 != nil {
		ogenVal := om.OptionalFixed32.Value
		{
			ogenVal = *pm.OptionalFixed32
		}
		om.OptionalFixed32.SetTo(ogenVal)
	}

	if pm.OptionalFixed64 != nil {
		ogenVal := om.OptionalFixed64.Value
		{
			ogenVal = *pm.OptionalFixed64
		}
		om.OptionalFixed64.SetTo(ogenVal)
	}

	if pm.OptionalSfixed32 != nil {
		ogenVal := om.OptionalSfixed32.Value
		{
			ogenVal = *pm.OptionalSfixed32
		}
		om.OptionalSfixed32.SetTo(ogenVal)
	}

	if pm.OptionalSfixed64 != nil {
		ogenVal := om.OptionalSfixed64.Value
		{
			ogenVal = *pm.OptionalSfixed64
		}
		om.OptionalSfixed64.SetTo(ogenVal)
	}

	{
		for _, protoVal := range pm.RepeatedInt64 {
			ogenElem := elemOf(om.RepeatedInt64)
			{
				ogenElem = protoVal
			}

			om.RepeatedInt64 = append(om.RepeatedInt64, ogenElem)
		}
	}

	{
		for _, protoVal := range pm.RepeatedUint64 {
			ogenElem := elemOf(om.RepeatedUint64)
			{
				ogenElem = protoVal
			}

			om.RepeatedUint64 = append(om.RepeatedUint64, ogenElem)
		}
	}

	{
		for _, protoVal := range pm.RepeatedFixed64 {
			ogenElem := elemOf(om.RepeatedFixed64)
			{
				ogenElem = protoVal
			}

			om.RepeatedFixed64 = append(om.RepeatedFixed64, ogenElem)
		}
	}

	{
		for _, protoVal := range pm.RepeatedSfixed64 {
			ogenElem := elemOf(om.RepeatedSfixed64)
			{
				ogenElem = protoVal
			}

			om.RepeatedSfixed64 = append(om.RepeatedSfixed64, ogenElem)
		}
	}

	{
		for _, protoVal := range pm.RepeatedBool {
			ogenElem := elemOf(om.RepeatedBool)
			{
				ogenElem = protoVal
			}

			om.RepeatedBool = append(om.RepeatedBool, ogenElem)
		}
	}

	{
		for _, protoVal := range pm.RepeatedString {
			ogenElem := elemOf(om.RepeatedString)
			{
				ogenElem = protoVal
			}

			om.RepeatedString = append(om.RepeatedString, ogenElem)
		}
	}

	if pm.NestedChild_1 != nil {
		ogenVal := om.NestedChild1.Value
		{
			ogenVal = pm.NestedChild_1.ToOpenAPI()
		}
		om.NestedChild1.SetTo(ogenVal)
	}

	if pm.ChildModel_1 != nil {
		ogenVal := om.ChildModel1.Value
		{
			ogenVal = pm.ChildModel_1.ToOpenAPI()
		}
		om.ChildModel1.SetTo(ogenVal)
	}

	{
		for _, protoVal := range pm.ChildModel_2 {
			ogenElem := elemOf(om.ChildModel2)
			{
				ogenElem = protoVal.ToOpenAPI()
			}

			om.ChildModel2 = append(om.ChildModel2, ogenElem)
		}
	}

	if pm.Bar != nil {
		ogenVal := om.Bar.Value
		{
			ogenVal = pm.Bar.ToOpenAPI()
		}
		om.Bar.SetTo(ogenVal)
	}

	if pm.RecursiveChild != nil {
		ogenVal := indirectOf(om.RecursiveChild)
		{
			ogenVal = pm.RecursiveChild.ToOpenAPI()
		}
		om.RecursiveChild = &ogenVal
	}

	if pm.ChildStrMap != nil {
		ogenVal := om.ChildStrMap.Value
		{
			for key, protoVal := range pm.ChildStrMap {
				ogenElem := valueOf(ogenVal)
				{
					ogenElem = protoVal.ToOpenAPI()
				}

				insertMap(&ogenVal, key, ogenElem)
			}
		}
		om.ChildStrMap.SetTo(ogenVal)
	}

	if pm.StrToIntMap != nil {
		ogenVal := om.StrToIntMap.Value
		{
			for key, protoVal := range pm.StrToIntMap {
				ogenElem := valueOf(ogenVal)
				{
					ogenElem = protoVal
				}

				insertMap(&ogenVal, key, ogenElem)
			}
		}
		om.StrToIntMap.SetTo(ogenVal)
	}

	if pm.StrToStrMap != nil {
		ogenVal := om.StrToStrMap.Value
		{
			for key, protoVal := range pm.StrToStrMap {
				ogenElem := valueOf(ogenVal)
				{
					ogenElem = protoVal
				}

				insertMap(&ogenVal, key, ogenElem)
			}
		}
		om.StrToStrMap.SetTo(ogenVal)
	}

	if pm.Category != nil {
		ogenVal := om.Category.Value
		{
			ogenVal = pm.Category.ToOpenAPI()
		}
		om.Category.SetTo(ogenVal)
	}

	if pm.Template != nil {
		ogenVal := om.Template.Value
		{
			ogenVal = *pm.Template
		}
		om.Template.SetTo(ogenVal)
	}

	if pm.Msg != nil {
		ogenVal := om.Msg.Value
		{
			ogenVal = *pm.Msg
		}
		om.Msg.SetTo(ogenVal)
	}

	if pm.Arena != nil {
		ogenVal := om.Arena.Value
		{
			ogenVal = *pm.Arena
		}
		om.Arena.SetTo(ogenVal)
	}

	if pm.ImportedEnum != nil {
		ogenVal := om.ImportedEnum.Value
		{
			ogenVal = pm.ImportedEnum.ToOpenAPI()
		}
		om.ImportedEnum.SetTo(ogenVal)
	}

	if pm.Phase != nil {
		ogenVal := om.Phase.Value
		{
			ogenVal = *pm.Phase
		}
		om.Phase.SetTo(ogenVal)
	}

	if pm.ClearPhase != nil {
		ogenVal := om.ClearPhase.Value
		{
			ogenVal = *pm.ClearPhase
		}
		om.ClearPhase.SetTo(ogenVal)
	}
	return om
}

func (pm *TestModel_NestedChild) FromOpenAPI(om oas.TestModelNestedChild) {
	if ogenVal, ok := om.NestedChildName.Get(); ok {
		pm.NestedChildName = &ogenVal
	}
}

func (pm *TestModel_NestedChild) ToOpenAPI() (om oas.TestModelNestedChild) {
	if pm.NestedChildName != nil {
		ogenVal := om.NestedChildName.Value
		{
			ogenVal = *pm.NestedChildName
		}
		om.NestedChildName.SetTo(ogenVal)
	}
	return om
}

func (pm *TestEnum) FromOpenAPI(om oas.TestEnum) {
	idx := TestEnum_value[string(om)]
	*pm = TestEnum(idx)
}

func (pm TestEnum) ToOpenAPI() oas.TestEnum {
	name := TestEnum_name[int32(pm)]
	return oas.TestEnum(name)
}

func (pm *TestModel_Category) FromOpenAPI(om oas.TestModelCategory) {
	idx := TestModel_Category_value[string(om)]
	*pm = TestModel_Category(idx)
}

func (pm TestModel_Category) ToOpenAPI() oas.TestModelCategory {
	name := TestModel_Category_name[int32(pm)]
	return oas.TestModelCategory(name)
}
