// Code generated by ogen, DO NOT EDIT.

package oas

import (
	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
)

// Encode implements json.Marshaler.
func (s *ChildModel1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChildModel1) encodeFields(e *jx.Encoder) {
	{
		if s.ChildB1.Set {
			e.FieldStart("childB1")
			s.ChildB1.Encode(e)
		}
	}
	{
		if s.ChildStr1.Set {
			e.FieldStart("childStr1")
			s.ChildStr1.Encode(e)
		}
	}
}

var jsonFieldsNameOfChildModel1 = [2]string{
	0: "childB1",
	1: "childStr1",
}

// Decode decodes ChildModel1 from json.
func (s *ChildModel1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChildModel1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "childB1":
			if err := func() error {
				s.ChildB1.Reset()
				if err := s.ChildB1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"childB1\"")
			}
		case "childStr1":
			if err := func() error {
				s.ChildStr1.Reset()
				if err := s.ChildStr1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"childStr1\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChildModel1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChildModel1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChildModel1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ChildModel1 as json.
func (o OptChildModel1) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ChildModel1 from json.
func (o *OptChildModel1) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptChildModel1 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptChildModel1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptChildModel1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestEnum as json.
func (o OptTestEnum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestEnum from json.
func (o *OptTestEnum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestEnum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestModel as json.
func (o OptTestModel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestModel from json.
func (o *OptTestModel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestModel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestModelCategory as json.
func (o OptTestModelCategory) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TestModelCategory from json.
func (o *OptTestModelCategory) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestModelCategory to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestModelCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestModelCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestModelChildStrMap as json.
func (o OptTestModelChildStrMap) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestModelChildStrMap from json.
func (o *OptTestModelChildStrMap) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestModelChildStrMap to nil")
	}
	o.Set = true
	o.Value = make(TestModelChildStrMap)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestModelChildStrMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestModelChildStrMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestModelNestedChild as json.
func (o OptTestModelNestedChild) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestModelNestedChild from json.
func (o *OptTestModelNestedChild) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestModelNestedChild to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestModelNestedChild) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestModelNestedChild) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestModelStrToIntMap as json.
func (o OptTestModelStrToIntMap) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestModelStrToIntMap from json.
func (o *OptTestModelStrToIntMap) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestModelStrToIntMap to nil")
	}
	o.Set = true
	o.Value = make(TestModelStrToIntMap)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestModelStrToIntMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestModelStrToIntMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestModelStrToStrMap as json.
func (o OptTestModelStrToStrMap) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TestModelStrToStrMap from json.
func (o *OptTestModelStrToStrMap) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTestModelStrToStrMap to nil")
	}
	o.Set = true
	o.Value = make(TestModelStrToStrMap)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTestModelStrToStrMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTestModelStrToStrMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uint32 as json.
func (o OptUint32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.UInt32(uint32(o.Value))
}

// Decode decodes uint32 from json.
func (o *OptUint32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUint32 to nil")
	}
	o.Set = true
	v, err := d.UInt32()
	if err != nil {
		return err
	}
	o.Value = uint32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUint32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUint32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uint64 as json.
func (o OptUint64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.UInt64(uint64(o.Value))
}

// Decode decodes uint64 from json.
func (o *OptUint64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUint64 to nil")
	}
	o.Set = true
	v, err := d.UInt64()
	if err != nil {
		return err
	}
	o.Value = uint64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUint64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUint64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StringMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StringMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfStringMessage = [1]string{
	0: "value",
}

// Decode decodes StringMessage from json.
func (s *StringMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StringMessage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StringMessage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StringMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StringMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestEnum as json.
func (s TestEnum) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestEnum from json.
func (s *TestEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestEnum to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestEnum(v) {
	case TestEnumDEVICEUNKNOWN:
		*s = TestEnumDEVICEUNKNOWN
	case TestEnumDEVICEKEYBOARD:
		*s = TestEnumDEVICEKEYBOARD
	case TestEnumDEVICEMOUSE:
		*s = TestEnumDEVICEMOUSE
	case TestEnumDEVICEMONITOR:
		*s = TestEnumDEVICEMONITOR
	default:
		*s = TestEnum(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestModel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestModel) encodeFields(e *jx.Encoder) {
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
	{
		if s.ValueArray != nil {
			e.FieldStart("valueArray")
			e.ArrStart()
			for _, elem := range s.ValueArray {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ValueDeprec != nil {
			e.FieldStart("valueDeprec")
			e.ArrStart()
			for _, elem := range s.ValueDeprec {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Str1.Set {
			e.FieldStart("str1")
			s.Str1.Encode(e)
		}
	}
	{
		if s.B1.Set {
			e.FieldStart("b1")
			s.B1.Encode(e)
		}
	}
	{
		if s.B2.Set {
			e.FieldStart("b2")
			s.B2.Encode(e)
		}
	}
	{
		if s.Str2.Set {
			e.FieldStart("str2")
			s.Str2.Encode(e)
		}
	}
	{
		if s.Str3.Set {
			e.FieldStart("str3")
			s.Str3.Encode(e)
		}
	}
	{
		if s.OptionalFloat.Set {
			e.FieldStart("optionalFloat")
			s.OptionalFloat.Encode(e)
		}
	}
	{
		if s.OptionalDouble.Set {
			e.FieldStart("optionalDouble")
			s.OptionalDouble.Encode(e)
		}
	}
	{
		if s.OptionalInt64.Set {
			e.FieldStart("optionalInt64")
			s.OptionalInt64.Encode(e)
		}
	}
	{
		if s.OptionalUint32.Set {
			e.FieldStart("optionalUint32")
			s.OptionalUint32.Encode(e)
		}
	}
	{
		if s.OptionalUint64.Set {
			e.FieldStart("optionalUint64")
			s.OptionalUint64.Encode(e)
		}
	}
	{
		if s.OptionalSint32.Set {
			e.FieldStart("optionalSint32")
			s.OptionalSint32.Encode(e)
		}
	}
	{
		if s.OptionalSint64.Set {
			e.FieldStart("optionalSint64")
			s.OptionalSint64.Encode(e)
		}
	}
	{
		if s.OptionalFixed32.Set {
			e.FieldStart("optionalFixed32")
			s.OptionalFixed32.Encode(e)
		}
	}
	{
		if s.OptionalFixed64.Set {
			e.FieldStart("optionalFixed64")
			s.OptionalFixed64.Encode(e)
		}
	}
	{
		if s.OptionalSfixed32.Set {
			e.FieldStart("optionalSfixed32")
			s.OptionalSfixed32.Encode(e)
		}
	}
	{
		if s.OptionalSfixed64.Set {
			e.FieldStart("optionalSfixed64")
			s.OptionalSfixed64.Encode(e)
		}
	}
	{
		if s.RepeatedInt64 != nil {
			e.FieldStart("repeatedInt64")
			e.ArrStart()
			for _, elem := range s.RepeatedInt64 {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepeatedUint64 != nil {
			e.FieldStart("repeatedUint64")
			e.ArrStart()
			for _, elem := range s.RepeatedUint64 {
				e.UInt64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepeatedFixed64 != nil {
			e.FieldStart("repeatedFixed64")
			e.ArrStart()
			for _, elem := range s.RepeatedFixed64 {
				e.UInt64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepeatedSfixed64 != nil {
			e.FieldStart("repeatedSfixed64")
			e.ArrStart()
			for _, elem := range s.RepeatedSfixed64 {
				e.Int64(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepeatedBool != nil {
			e.FieldStart("repeatedBool")
			e.ArrStart()
			for _, elem := range s.RepeatedBool {
				e.Bool(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RepeatedString != nil {
			e.FieldStart("repeatedString")
			e.ArrStart()
			for _, elem := range s.RepeatedString {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NestedChild1.Set {
			e.FieldStart("nestedChild1")
			s.NestedChild1.Encode(e)
		}
	}
	{
		if s.ChildModel1.Set {
			e.FieldStart("childModel1")
			s.ChildModel1.Encode(e)
		}
	}
	{
		if s.ChildModel2 != nil {
			e.FieldStart("childModel2")
			e.ArrStart()
			for _, elem := range s.ChildModel2 {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Bar.Set {
			e.FieldStart("bar")
			s.Bar.Encode(e)
		}
	}
	{
		if s.OneofMember1.Set {
			e.FieldStart("oneofMember1")
			s.OneofMember1.Encode(e)
		}
	}
	{
		if s.OneofMember2.Set {
			e.FieldStart("oneofMember2")
			s.OneofMember2.Encode(e)
		}
	}
	{
		if s.RecursiveChild != nil {
			e.FieldStart("recursiveChild")
			s.RecursiveChild.Encode(e)
		}
	}
	{
		if s.ChildStrMap.Set {
			e.FieldStart("childStrMap")
			s.ChildStrMap.Encode(e)
		}
	}
	{
		if s.StrToIntMap.Set {
			e.FieldStart("strToIntMap")
			s.StrToIntMap.Encode(e)
		}
	}
	{
		if s.StrToStrMap.Set {
			e.FieldStart("strToStrMap")
			s.StrToStrMap.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.String.Set {
			e.FieldStart("string")
			s.String.Encode(e)
		}
	}
	{
		if s.Int64.Set {
			e.FieldStart("int64")
			s.Int64.Encode(e)
		}
	}
	{
		if s.Double.Set {
			e.FieldStart("double")
			s.Double.Encode(e)
		}
	}
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
	{
		if s.Msg.Set {
			e.FieldStart("msg")
			s.Msg.Encode(e)
		}
	}
	{
		if s.Arena.Set {
			e.FieldStart("arena")
			s.Arena.Encode(e)
		}
	}
	{
		if s.ImportedEnum.Set {
			e.FieldStart("importedEnum")
			s.ImportedEnum.Encode(e)
		}
	}
	{
		if s.Phase.Set {
			e.FieldStart("phase")
			s.Phase.Encode(e)
		}
	}
	{
		if s.ClearPhase.Set {
			e.FieldStart("clearPhase")
			s.ClearPhase.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestModel = [45]string{
	0:  "value",
	1:  "valueArray",
	2:  "valueDeprec",
	3:  "str1",
	4:  "b1",
	5:  "b2",
	6:  "str2",
	7:  "str3",
	8:  "optionalFloat",
	9:  "optionalDouble",
	10: "optionalInt64",
	11: "optionalUint32",
	12: "optionalUint64",
	13: "optionalSint32",
	14: "optionalSint64",
	15: "optionalFixed32",
	16: "optionalFixed64",
	17: "optionalSfixed32",
	18: "optionalSfixed64",
	19: "repeatedInt64",
	20: "repeatedUint64",
	21: "repeatedFixed64",
	22: "repeatedSfixed64",
	23: "repeatedBool",
	24: "repeatedString",
	25: "nestedChild1",
	26: "childModel1",
	27: "childModel2",
	28: "bar",
	29: "oneofMember1",
	30: "oneofMember2",
	31: "recursiveChild",
	32: "childStrMap",
	33: "strToIntMap",
	34: "strToStrMap",
	35: "category",
	36: "string",
	37: "int64",
	38: "double",
	39: "template",
	40: "msg",
	41: "arena",
	42: "importedEnum",
	43: "phase",
	44: "clearPhase",
}

// Decode decodes TestModel from json.
func (s *TestModel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestModel to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "valueArray":
			if err := func() error {
				s.ValueArray = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.ValueArray = append(s.ValueArray, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valueArray\"")
			}
		case "valueDeprec":
			if err := func() error {
				s.ValueDeprec = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.ValueDeprec = append(s.ValueDeprec, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valueDeprec\"")
			}
		case "str1":
			if err := func() error {
				s.Str1.Reset()
				if err := s.Str1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"str1\"")
			}
		case "b1":
			if err := func() error {
				s.B1.Reset()
				if err := s.B1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"b1\"")
			}
		case "b2":
			if err := func() error {
				s.B2.Reset()
				if err := s.B2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"b2\"")
			}
		case "str2":
			if err := func() error {
				s.Str2.Reset()
				if err := s.Str2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"str2\"")
			}
		case "str3":
			if err := func() error {
				s.Str3.Reset()
				if err := s.Str3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"str3\"")
			}
		case "optionalFloat":
			if err := func() error {
				s.OptionalFloat.Reset()
				if err := s.OptionalFloat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalFloat\"")
			}
		case "optionalDouble":
			if err := func() error {
				s.OptionalDouble.Reset()
				if err := s.OptionalDouble.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalDouble\"")
			}
		case "optionalInt64":
			if err := func() error {
				s.OptionalInt64.Reset()
				if err := s.OptionalInt64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalInt64\"")
			}
		case "optionalUint32":
			if err := func() error {
				s.OptionalUint32.Reset()
				if err := s.OptionalUint32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalUint32\"")
			}
		case "optionalUint64":
			if err := func() error {
				s.OptionalUint64.Reset()
				if err := s.OptionalUint64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalUint64\"")
			}
		case "optionalSint32":
			if err := func() error {
				s.OptionalSint32.Reset()
				if err := s.OptionalSint32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalSint32\"")
			}
		case "optionalSint64":
			if err := func() error {
				s.OptionalSint64.Reset()
				if err := s.OptionalSint64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalSint64\"")
			}
		case "optionalFixed32":
			if err := func() error {
				s.OptionalFixed32.Reset()
				if err := s.OptionalFixed32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalFixed32\"")
			}
		case "optionalFixed64":
			if err := func() error {
				s.OptionalFixed64.Reset()
				if err := s.OptionalFixed64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalFixed64\"")
			}
		case "optionalSfixed32":
			if err := func() error {
				s.OptionalSfixed32.Reset()
				if err := s.OptionalSfixed32.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalSfixed32\"")
			}
		case "optionalSfixed64":
			if err := func() error {
				s.OptionalSfixed64.Reset()
				if err := s.OptionalSfixed64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"optionalSfixed64\"")
			}
		case "repeatedInt64":
			if err := func() error {
				s.RepeatedInt64 = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.RepeatedInt64 = append(s.RepeatedInt64, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeatedInt64\"")
			}
		case "repeatedUint64":
			if err := func() error {
				s.RepeatedUint64 = make([]uint64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uint64
					v, err := d.UInt64()
					elem = uint64(v)
					if err != nil {
						return err
					}
					s.RepeatedUint64 = append(s.RepeatedUint64, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeatedUint64\"")
			}
		case "repeatedFixed64":
			if err := func() error {
				s.RepeatedFixed64 = make([]uint64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uint64
					v, err := d.UInt64()
					elem = uint64(v)
					if err != nil {
						return err
					}
					s.RepeatedFixed64 = append(s.RepeatedFixed64, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeatedFixed64\"")
			}
		case "repeatedSfixed64":
			if err := func() error {
				s.RepeatedSfixed64 = make([]int64, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int64
					v, err := d.Int64()
					elem = int64(v)
					if err != nil {
						return err
					}
					s.RepeatedSfixed64 = append(s.RepeatedSfixed64, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeatedSfixed64\"")
			}
		case "repeatedBool":
			if err := func() error {
				s.RepeatedBool = make([]bool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem bool
					v, err := d.Bool()
					elem = bool(v)
					if err != nil {
						return err
					}
					s.RepeatedBool = append(s.RepeatedBool, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeatedBool\"")
			}
		case "repeatedString":
			if err := func() error {
				s.RepeatedString = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RepeatedString = append(s.RepeatedString, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repeatedString\"")
			}
		case "nestedChild1":
			if err := func() error {
				s.NestedChild1.Reset()
				if err := s.NestedChild1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nestedChild1\"")
			}
		case "childModel1":
			if err := func() error {
				s.ChildModel1.Reset()
				if err := s.ChildModel1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"childModel1\"")
			}
		case "childModel2":
			if err := func() error {
				s.ChildModel2 = make([]ChildModel1, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChildModel1
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ChildModel2 = append(s.ChildModel2, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"childModel2\"")
			}
		case "bar":
			if err := func() error {
				s.Bar.Reset()
				if err := s.Bar.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bar\"")
			}
		case "oneofMember1":
			if err := func() error {
				s.OneofMember1.Reset()
				if err := s.OneofMember1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oneofMember1\"")
			}
		case "oneofMember2":
			if err := func() error {
				s.OneofMember2.Reset()
				if err := s.OneofMember2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oneofMember2\"")
			}
		case "recursiveChild":
			if err := func() error {
				s.RecursiveChild = nil
				var elem TestModel
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RecursiveChild = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recursiveChild\"")
			}
		case "childStrMap":
			if err := func() error {
				s.ChildStrMap.Reset()
				if err := s.ChildStrMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"childStrMap\"")
			}
		case "strToIntMap":
			if err := func() error {
				s.StrToIntMap.Reset()
				if err := s.StrToIntMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strToIntMap\"")
			}
		case "strToStrMap":
			if err := func() error {
				s.StrToStrMap.Reset()
				if err := s.StrToStrMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strToStrMap\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "string":
			if err := func() error {
				s.String.Reset()
				if err := s.String.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"string\"")
			}
		case "int64":
			if err := func() error {
				s.Int64.Reset()
				if err := s.Int64.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"int64\"")
			}
		case "double":
			if err := func() error {
				s.Double.Reset()
				if err := s.Double.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"double\"")
			}
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "msg":
			if err := func() error {
				s.Msg.Reset()
				if err := s.Msg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"msg\"")
			}
		case "arena":
			if err := func() error {
				s.Arena.Reset()
				if err := s.Arena.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arena\"")
			}
		case "importedEnum":
			if err := func() error {
				s.ImportedEnum.Reset()
				if err := s.ImportedEnum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"importedEnum\"")
			}
		case "phase":
			if err := func() error {
				s.Phase.Reset()
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "clearPhase":
			if err := func() error {
				s.ClearPhase.Reset()
				if err := s.ClearPhase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clearPhase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestModel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestModel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestModel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TestModelCategory as json.
func (s TestModelCategory) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TestModelCategory from json.
func (s *TestModelCategory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestModelCategory to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TestModelCategory(v) {
	case TestModelCategoryUNKNOWN:
		*s = TestModelCategoryUNKNOWN
	case TestModelCategoryIMAGES:
		*s = TestModelCategoryIMAGES
	case TestModelCategoryNEWS:
		*s = TestModelCategoryNEWS
	case TestModelCategoryVIDEO:
		*s = TestModelCategoryVIDEO
	case TestModelCategoryRADIO:
		*s = TestModelCategoryRADIO
	default:
		*s = TestModelCategory(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestModelCategory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestModelCategory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TestModelChildStrMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TestModelChildStrMap) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes TestModelChildStrMap from json.
func (s *TestModelChildStrMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestModelChildStrMap to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem ChildModel1
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestModelChildStrMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestModelChildStrMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestModelChildStrMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TestModelNestedChild) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TestModelNestedChild) encodeFields(e *jx.Encoder) {
	{
		if s.NestedChildName.Set {
			e.FieldStart("nestedChildName")
			s.NestedChildName.Encode(e)
		}
	}
}

var jsonFieldsNameOfTestModelNestedChild = [1]string{
	0: "nestedChildName",
}

// Decode decodes TestModelNestedChild from json.
func (s *TestModelNestedChild) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestModelNestedChild to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nestedChildName":
			if err := func() error {
				s.NestedChildName.Reset()
				if err := s.NestedChildName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nestedChildName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestModelNestedChild")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TestModelNestedChild) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestModelNestedChild) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TestModelStrToIntMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TestModelStrToIntMap) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int32(elem)
	}
}

// Decode decodes TestModelStrToIntMap from json.
func (s *TestModelStrToIntMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestModelStrToIntMap to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int32
		if err := func() error {
			v, err := d.Int32()
			elem = int32(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestModelStrToIntMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestModelStrToIntMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestModelStrToIntMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s TestModelStrToStrMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s TestModelStrToStrMap) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes TestModelStrToStrMap from json.
func (s *TestModelStrToStrMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TestModelStrToStrMap to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TestModelStrToStrMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TestModelStrToStrMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TestModelStrToStrMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
